# 垃圾回收机制

## 内存泄漏

程序的运行需要内存。只要程序提出要求，操作系统或者运行时（*runtime*）就必须供给内存。

对于持续运行的服务进程（*daemon*），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。

也就是说，不再用到的内存，如果没有及时释放，就叫做内存泄漏（*memory leak*）。

## 什么是垃圾回收机制？

浏览器的 Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存。其原理是：**垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存**。

但是这个过程不是实时的，因为其开销比较大并且 GC 时停止响应其他操作，所以垃圾回收器会按照固定的时间间隔周期性的执行。

不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。因此使用闭包会导致内存泄漏。

下面是一段示例代码：

```js
function fn1() {
    var obj = {name: 'zhangsan', age: 10};
}
function fn2() {
    var obj = {name:'zhangsan', age: 10};
    return obj;
}

var a = fn1();
var b = fn2();
```

在上面的代码中，我们首先声明了两个函数，分别叫做 fn1 和 fn2。

当 fn1 被调用时，进入 fn1 的环境，会开辟一块内存存放对象 `{name: 'zhangsan', age: 10}`。而当调用结束后，出了 fn1 的环境，那么该块内存会被 JavaScript 引擎中的垃圾回收器自动释放。

在 fn2 被调用的过程中，返回的对象被全局变量 b 所指向，所以该块内存并不会被释放。

这里问题就出现了：到底哪个变量是没有用的？

所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其内存。

用于标记的无用变量的策略可能因实现而有所区别，通常情况下有两种实现方式：**标记清除**和**引用计数**。

引用计数不太常用，标记清除较为常用。

## 标记清除





## 引用计数





